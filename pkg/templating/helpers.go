package templating

import (
	"errors"
	"fmt"
	"path/filepath"
	"reflect"
	"regexp"
	"text/template"

	"strings"

	"github.com/go-openapi/swag"
	"gopkg.in/yaml.v3"
)

// ToGoPackageName returns lowercase string without separator.
var ToGoPackageName = func(name string) string {
	return strings.ToLower(swag.ToGoName(name))
}

// ToGoName sanitizes a name for a public Go variable.
var ToGoName = swag.ToGoName

// ToVarName sanitizes a name for a Go variable.
var ToVarName = swag.ToVarName

// ToFileName sanitizes a name for a filename.
var ToFileName = swag.ToFileName

// ToCommandName sanitizes a name for a command.
var ToCommandName = swag.ToCommandName

// ToYAML returns the yaml version of the input.
func ToYAML(s interface{}) string {
	result, err := yaml.Marshal(s)
	if err != nil {
		panic(err)
	}
	return string(result)
}

func getHeaderMessage(message string) string {
	return fmt.Sprintf(
		"Generated with the cestus.io codegenerator\n\n%s",
		message,
	)
}

// CodeSectionFileHeader return a header for file using code sections.
func CodeSectionFileHeader() string {
	return getHeaderMessage("Modifications in code regions will be lost during regeneration!")
}

// FullyEditableFileHeader return a header for fully editable files.
func FullyEditableFileHeader() string { return getHeaderMessage("You CAN edit this file !") }

// NonEditableFileHeader return a header non editable files.
func NonEditableFileHeader() string { return getHeaderMessage("DO NOT EDIT THIS FILE !") }

func commentLines(input, commentChars string) string {
	result := strings.Replace(commentChars+" "+input, "\n", "\n"+commentChars+" ", -1)
	return strings.Replace(result, " \n", "\n", -1)
}

// ToGoComment comments the input using go comments `//`.
func ToGoComment(input string) string { return commentLines(input, "//") }

// ToYAMLComment comments the input using yaml comments `#`.
func ToYAMLComment(input string) string { return commentLines(input, "#") }

// ToMarkdownQuote sets the input using markdown quote.
func ToMarkdownQuote(input string) string { return commentLines(input, ">") }

// ToMap takes a list of strings as key-value pairs and returns a map.
func ToMap(input ...string) map[string]string {
	if len(input)%2 != 0 {
		panic(errors.New("odd number of values in ToMap call, expected a list of key-value pairs"))
	}

	results := make(map[string]string)

	for i := 0; i < len(input); i += 2 {
		key := input[i]
		value := input[i+1]
		results[key] = value
	}

	return results
}

// ReplacePathVar replaces a variable in a path, if it exists.
//
// If it doesn't, the path is returned unchanged.
func ReplacePathVar(varName string, value interface{}, path string) string {
	re := regexp.MustCompile(fmt.Sprintf(`^(.*)\{[ ]*%s[ ]*\}(.*)$`, regexp.QuoteMeta(varName)))
	return re.ReplaceAllString(path, fmt.Sprintf(`${1}%v${2}`, value))
}

// ReplacePathVars replaces all variables in a path.
//
// If no variable is present, the path is returned unchanged.
func ReplacePathVars(value interface{}, path string) string {
	re := regexp.MustCompile(`\{[ ]*[\w\-]+[ ]*\}`)
	return re.ReplaceAllString(path, fmt.Sprintf(`${1}%v${2}`, value))
}

// IsLast returns true if index is last element of slice
func IsLast(index int, slice interface{}) bool {
	return index == reflect.ValueOf(slice).Len()-1
}

// Capitalize returns a copy of the string with its first character capitalized and the rest lowercased
func Capitalize(s string) string {
	return strings.ToUpper(string(s[0])) + strings.ToLower(s[1:])
}

var templatesFuncMap = template.FuncMap{
	"ToGoName":                ToGoName,
	"ToVarName":               ToVarName,
	"ToFileName":              ToFileName,
	"ToCommandName":           ToCommandName,
	"ToGoPackageName":         ToGoPackageName,
	"ToYAML":                  ToYAML,
	"ToHumanNameTitle":        swag.ToHumanNameTitle,
	"CodeSectionFileHeader":   CodeSectionFileHeader,
	"NonEditableFileHeader":   NonEditableFileHeader,
	"FullyEditableFileHeader": FullyEditableFileHeader,
	"ToYAMLComment":           ToYAMLComment,
	"ToGoComment":             ToGoComment,
	"ToMarkdownQuote":         ToMarkdownQuote,
	"ToMap":                   ToMap,
	"ToSlash":                 filepath.ToSlash,
	"ReplacePathVar":          ReplacePathVar,
	"ReplacePathVars":         ReplacePathVars,
	"Rel":                     filepath.Rel,
	"IsLast":                  IsLast,
	"Capitalize":              Capitalize,
}
