package templating

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestToYAML(t *testing.T) {
	reference := 1
	expected := "1\n"
	value := ToYAML(reference)

	if value != expected {
		t.Errorf("expected \"%s\", got \"%s\"", expected, value)
	}
}

func TestToGoPackageName(t *testing.T) {
	assert.Equal(t, ToGoPackageName("TEST_To-GO-packageName"), "testtogopackagename")
}

func TestGetHeaderMessage(t *testing.T) {
	assert.Equal(t, getHeaderMessage("some message"), "Generated with the cestus.io codegenerator\n\nsome message")
}

func TestCodeSectionFileHeader(t *testing.T) {
	assert.Equal(t, CodeSectionFileHeader(), "Generated with the cestus.io codegenerator\n\nModifications in code regions will be lost during regeneration!")
}

func TestFullyEditableFileHeader(t *testing.T) {
	assert.Equal(t, FullyEditableFileHeader(), "Generated with the cestus.io codegenerator\n\nYou CAN edit this file !")
}

func TestNonEditableFileHeader(t *testing.T) {
	assert.Equal(t, NonEditableFileHeader(), "Generated with the cestus.io codegenerator\n\nDO NOT EDIT THIS FILE !")
}

func TestToGoComment(t *testing.T) {
	assert.Equal(t, ToGoComment("AAA\n\nBBB"), "// AAA\n//\n// BBB")
}

func TestToYAMLComment(t *testing.T) {
	assert.Equal(t, ToYAMLComment("AAA\n\nBBB"), "# AAA\n#\n# BBB")
}

func TestToMarkdownQuote(t *testing.T) {
	assert.Equal(t, ToMarkdownQuote("AAA\n\nBBB"), "> AAA\n>\n> BBB")
}

func TestReplacePathVar(t *testing.T) {
	testCases := []struct {
		Path     string
		Var      string
		Value    interface{}
		Expected string
	}{
		{
			Path:     "/v1/spaces/{space-id}/foo/{bar}/moo",
			Var:      "space-id",
			Value:    "0000-abcd",
			Expected: "/v1/spaces/0000-abcd/foo/{bar}/moo",
		},
		{
			Path:     "/v1/spaces/{space-id}/foo/{bar}/moo",
			Var:      "bar",
			Value:    14,
			Expected: "/v1/spaces/{space-id}/foo/14/moo",
		},
		{
			Path:     "/v1/spaces/prefix{ space-id }/foo/prefix{bar}/moo",
			Var:      "space-id",
			Value:    "0000-abcd",
			Expected: "/v1/spaces/prefix0000-abcd/foo/prefix{bar}/moo",
		},
		{
			Path:     "/v1/spaces/0000-abcd/foo/14/moo",
			Var:      "spaces",
			Value:    "nope",
			Expected: "/v1/spaces/0000-abcd/foo/14/moo",
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.Path, func(t *testing.T) {
			result := ReplacePathVar(testCase.Var, testCase.Value, testCase.Path)

			assert.Equal(t, testCase.Expected, result)
		})
	}
}

func TestReplacePathVars(t *testing.T) {
	testCases := []struct {
		Path     string
		Value    interface{}
		Expected string
	}{
		{
			Path:     "/v1/spaces/{space-id}/foo/{bar}/moo",
			Value:    "hello",
			Expected: "/v1/spaces/hello/foo/hello/moo",
		},
		{
			Path:     "/v1/spaces{a_4b}/prefix{space-id}/foo/prefix{bar}/moo",
			Value:    14,
			Expected: "/v1/spaces14/prefix14/foo/prefix14/moo",
		},
		{
			Path:     "/v1/spaces/0000-abcd/foo/14/moo",
			Value:    "nope",
			Expected: "/v1/spaces/0000-abcd/foo/14/moo",
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.Path, func(t *testing.T) {
			result := ReplacePathVars(testCase.Value, testCase.Path)

			assert.Equal(t, testCase.Expected, result)
		})
	}
}
